#
# signal.test
#
# Tests for the signal and kill commands.
#---------------------------------------------------------------------------
# Copyright 1992 Karl Lehenbauer and Mark Diekhans.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose and without fee is hereby granted, provided
# that the above copyright notice appear in all copies.  Karl Lehenbauer and
# Mark Diekhans make no representations about the suitability of this
# software for any purpose.  It is provided "as is" without express or
# implied warranty.
#------------------------------------------------------------------------------
# $Id$
#------------------------------------------------------------------------------
#

if {[info procs test] != "test"} then {source testlib.tcl}

Test signal-1.1 {signal tests} {
    signal ignore SIGHUP
    kill HUP [id process]
} 0 {}

Test signal-1.2 {signal tests} {
    global errorInfo
    set errorInfo {}
    signal error HUP
    proc KillMe3 {} {kill SIGHUP [id process]}
    proc KillMe2 {} {KillMe3}
    proc KillMe1 {} {KillMe2}
    list [catch {KillMe1} msg] $msg $errorInfo
} 0 {1 {SIGHUP signal received} {SIGHUP signal received
    while executing
"kill SIGHUP [id process]"
    (procedure "KillMe3" line 1)
    invoked from within
"KillMe3"
    (procedure "KillMe2" line 1)
    invoked from within
"KillMe2"
    (procedure "KillMe1" line 1)
    invoked from within
"KillMe1"}}

Test signal-1.3 {signal tests} {
    signal error HUP SIGINT
    set one [list [catch {kill HUP [id process]} msg] $msg]
    set two [list [catch {kill INT [id process]} msg] $msg]
    list $one $two
} 0 {{1 {SIGHUP signal received}} {1 {SIGINT signal received}}}

Test signal-1.4 {signal tests} {
    set signalWeGot {}
    signal trap 1 {set signalWeGot $signalReceived} 
    kill SIGHUP [id process]
    signal default 1
    set signalWeGot
} 0 {SIGHUP}

Test signal-1.5 {signal tests} {
    signal default {SIGHUP SIGINT}
    signal get {SIGHUP SIGINT}
} 0 {{SIGHUP default} {SIGINT default}}

Test signal-1.6 {signal tests} {
    signal default SIGHUP
    signal ignore  SIGINT
    signal get {SIGHUP SIGINT}
} 0 {{SIGHUP default} {SIGINT ignore}}

Test signal-1.7 {signal tests} {
    signal trap {SIGHUP SIGINT} {error "Should not get this signal"}
    signal get {SIGHUP SIGINT}
} 0 [list {SIGHUP {trap {error "Should not get this signal"}}} \
          {SIGINT {trap {error "Should not get this signal"}}} ]

Test signal-1.8 {signal tests} {
    signal error {SIGHUP SIGINT}
    signal get {SIGHUP SIGINT}
} 0 {{SIGHUP error} {SIGINT error}}

Test signal-1.9 {signal tests} {
    global errorInfo
    set errorInfo {}
    proc KillMe3 {} {kill SIGHUP [id process]}
    proc KillMe2 {} {KillMe3}
    proc KillMe1 {} {KillMe2}
    signal trap SIGHUP {error "Blew it in the trap code"}
    list [catch {KillMe1} msg ] $msg $errorInfo
} 0 {1 {Blew it in the trap code} {Blew it in the trap code
    while executing
"error "Blew it in the trap code""
    while executing signal trap code for SIGHUP signal
    invoked from within
"kill SIGHUP [id process]"
    (procedure "KillMe3" line 1)
    invoked from within
"KillMe3"
    (procedure "KillMe2" line 1)
    invoked from within
"KillMe2"
    (procedure "KillMe1" line 1)
    invoked from within
"KillMe1"}}

Test signal-1.10 {signal tests} {
    signal
} 1 {wrong # args: signal action signalList [commands]}

Test signal-1.11 {signal tests} {
    signal ignore foo
} 1 {invalid signal name: foo}

#
# Complex test for the death of a child.
#

proc PollSigChld {} {
    global G_gotChild
    set sleepCnt 0
    while {!$G_gotChild} {
        incr sleepCnt
        if {$sleepCnt > 90} {
            error "signal-1.12: SIGCHLD lost"
        }
        sleep 1
    }
}

proc ForkChild {exitCode} {
    flush stdout  ;# Not going to exec, must clean up the buffers.
    flush stderr
    set childPid [fork]
    if {$childPid == 0} {
        sleep 1
        exit $exitCode
    }
    return $childPid
}

test signal-1.12 {signal tests} {
    global G_gotChild
    set G_gotChild 0
    signal trap SIGCHLD {global G_gotChild;set G_gotChild 1;sleep 1}
    set pid [ForkChild 123] 
    PollSigChld

    set status [wait $pid]
    lindex $status 2
} {123}

signal default SIGCHLD

Test signal-2.1 {kill tests} {
    kill
} 1 {wrong # args: kill [signal] processlist}

signal error SIGINT

Test signal-2.2 {kill tests} {
    kill 2 [id process]
} 1 {SIGINT signal received}

Test signal-2.3 {kill tests} {
    kill INT [id process]
} 1 {SIGINT signal received}

Test signal-2.4 {kill tests} {
    kill SIGINT [id process]
} 1 {SIGINT signal received}

Test signal-2.5 {kill tests} {
    kill 10000 [id process]
} 1 {invalid signal}

Test signal-2.6 {kill tests} {
    kill SIGFOO [id process]
} 1 {invalid signal}

Test signal-2.7 {kill tests} {
    kill 0 [id process]
} 0 {}
