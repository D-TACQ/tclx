#
# filecmds.test
#
# Tests for the copyfile, pipe, and frename commands.
#---------------------------------------------------------------------------
# Copyright 1992-1996 Karl Lehenbauer and Mark Diekhans.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose and without fee is hereby granted, provided
# that the above copyright notice appear in all copies.  Karl Lehenbauer and
# Mark Diekhans make no representations about the suitability of this
# software for any purpose.  It is provided "as is" without express or
# implied warranty.
#------------------------------------------------------------------------------
# $Id: filecmds.test,v 7.1 1996/07/26 05:56:18 markd Exp $
#------------------------------------------------------------------------------
#

if {[info procs test] != "test"} then {source testlib.tcl}

#
# Fork without exec will not work under Tk, skip this test
#
if ![lempty [info commands button]] {
    puts "*************************************************************"
    puts "File commands tests are constructed in a way that does not"
    puts "work under Tk.  Test skipped."
    puts "*************************************************************"
    puts ""
    return
}

#
# Compare the contents of two files.  Return 1 if the same, 0 if different.
#
proc TestCompareFiles {fn1 fn2} {
    set fh1 [open $fn1]
    fconfigure $fh1 -translation binary
    set data1 [read $fh1]
    close $fh1
    set fh2 [open $fn2]
    fconfigure $fh2 -translation binary
    set data2 [read $fh2]
    close $fh2
    return [cequal $data1 $data2]
}


# Create a test file

catch {unlink [glob IOTEST*.TMP]}

set testFH [open IOTEST.TMP w]
set testFileSize 0
for {set cnt 0} {$cnt < 100} {incr cnt} {
     set rec [GenRec $cnt]
     puts $testFH $rec
     incr testFileSize [expr [clength $rec]+1]
     if [cequal $tcl_platform(platform) windows] {
        incr testFileSize  ;# for <cr>
     }
}
close $testFH

if {$testFileSize != [file size IOTEST.TMP]} {
     error "Wrong file size calculated for IOTEST.TMP"
}

Test filecmds-3.1 {copyfile tests} {
    set testFH1 [open IOTEST.TMP r]
    set testFH2 [open IOTEST2.TMP w]
    copyfile $testFH1 $testFH2
    close $testFH1
    close $testFH2
    TestCompareFiles IOTEST.TMP IOTEST2.TMP
} 0 1

Test filecmds-3.1.1 {copyfile tests} {
    # Source/target open read-write.
    set testFH [open IOTEST.TMP r+]
    set testFH2 [open IOTEST2.TMP r+]
    seek $testFH2 0
    copyfile $testFH $testFH2
    close $testFH
    close $testFH2
    TestCompareFiles IOTEST.TMP IOTEST2.TMP
} 0 1

Test filecmds-3.2 {copyfile tests} {
    set testFH [open IOTEST3.TMP w]
    set testFH2 [open IOTEST2.TMP w]
    set stat [list [catch {copyfile $testFH $testFH2} msg] \
                   [lrange $msg 2 end]]
    close $testFH
    close $testFH2
    set stat
} 0 {1 {wasn't opened for reading}}

Test filecmds-3.3 {copyfile tests} {
    set testFH [open IOTEST.TMP r]
    set testFH2 [open IOTEST2.TMP r]
    set stat [list [catch {copyfile $testFH $testFH2} msg] \
                   [lrange $msg 2 end]]
    close $testFH
    close $testFH2
    set stat
} 0 {1 {wasn't opened for writing}}

Test filecmds-3.4 {copyfile tests} {
    copyfile $testFH $testFH2
} 1 "can not find channel named \"$testFH\""

Test filecmds-3.5 {copyfile tests} {
    copyfile
} 1 {wrong # args: copyfile ?-bytes num|-maxbytes num? ?-translate? fromFileId toFileId}

foreach flag {-bytes -maxbytes} {
    Test filecmds-3.6.$flag {copyfile tests} {
        set copySize [expr ($testFileSize*2)/3]
        set testFH [open IOTEST.TMP r]
        set testFH2 [open IOTEST2.TMP w]
        copyfile $flag $copySize $testFH $testFH2
        close $testFH
        close $testFH2
        list [expr [file size IOTEST2.TMP] == $copySize] \
             [TestCompareFiles IOTEST.TMP IOTEST2.TMP]
    } 0 {1 0}

    catch {unset testData testData2}
}

set copySize [expr $testFileSize*2]

Test filecmds-3.7 {copyfile tests} {
    set testFH [open IOTEST.TMP r]
    set testFH2 [open IOTEST2.TMP w]
    set stat [catch {copyfile -bytes $copySize $testFH $testFH2} msg]
    close $testFH
    close $testFH2
    list $stat $msg
} 0 [list 1 \
          "premature EOF, $copySize bytes expected, $testFileSize bytes actually read"]

Test filecmds-3.7 {copyfile tests} {
    set testFH [open IOTEST.TMP r]
    set testFH2 [open IOTEST2.TMP w]
    set stat [catch {copyfile -maxbytes $copySize $testFH $testFH2} msg]
    close $testFH
    close $testFH2
    list $stat $msg
} 0 [list 0 $testFileSize]

# FIX: Need win95 tests for pipe.

if [cequal $tcl_platform(platform) unix] {
    pipe readPF writePF

    flush stdout  ;# Not going to exec, must clean up the buffers.
    flush stderr
    set sonPid [fork]

    if {$sonPid == 0} {
        for {set cnt 0} {$cnt < 50} {incr cnt} {
            Test filecmds-4.1 {pipe tests} {
                if {![gets $readPF msgBuf]} {
                   set msgBuf "Premature eof on pipe"
                }
                set msgBuf
            } 0 [GenRec $cnt]
        }
        close $readPF
        exit 0
    }

    for {set cnt 0} {$cnt < 50} {incr cnt} {
        puts $writePF [GenRec $cnt]
    }
    flush $writePF
    Test filecmds-4.2 {pipe tests} {
        wait $sonPid
    } 0 "$sonPid EXIT 0"

    close $readPF
    close $writePF
}

Test filecmds-5.1 {frename tests} {
    frename
} 1 {wrong # args: frename oldPath newPath}

Test filecmds-5.2 {frename tests} {
    frename a b c
} 1 {wrong # args: frename oldPath newPath}

Test filecmds-5.3 {frename tests} {
    frename IOTEST.TMP IOTEST4.TMP
    file exists IOTEST4.TMP
} 0 1

Test filecmds-5.4 {frename tests} {
    unlink -nocomplain IOTEST5.TMP
    list [catch {frename IOTEST5.TMP IOTEST6.TMP} msg] [string tolower $msg]
} 0 {1 {rename "iotest5.tmp" to "iotest6.tmp" failed: no such file or directory}}

Test filecmds-6.1 {readdir tests} {
    readdir
} 1 {wrong # args: readdir ?-hidden? dirPath}

Test filecmds-6.1.1 {readdir tests} {
    readdir -hidden x y
} 1 {wrong # args: readdir ?-hidden? dirPath}

Test filecmds-6.2 {readdir tests} {
    readdir -x y
} 1 {expected option of "-hidden", got "-x"}

tcltouch READDIR.TMP/AAA
tcltouch READDIR.TMP/BBB
tcltouch READDIR.TMP/CCC
tcltouch READDIR.TMP/DDD

Test filecmds-6.3 {readdir tests} {
    lsort [readdir READDIR.TMP]
} 0 {AAA BBB CCC DDD}

Test filecmds-6.4 {readdir tests} {
    lsort [readdir -hidden READDIR.TMP]
} 0 {AAA BBB CCC DDD}

#
# ftruncate command.
#

proc CreateTmpFile {name size} {
    set fh [open $name w]
    puts -nonewline $fh [replicate X $size]
    close $fh
    if {[file size $name] != $size} {
        error "CreateTmpFile: [file size $name] != $size"
    }
}

Test filecmds-7.1 {ftruncate tests} {
    ftruncate 
} 1 {wrong # args: ftruncate [-fileid] file newsize}

Test filecmds-7.2 {ftruncate tests} {
    ftruncate TRUNCATE.TMP 10 1000 200
} 1 {wrong # args: ftruncate [-fileid] file newsize}

Test filecmds-7.3 {ftruncate tests} {
    ftruncate -fileid 10
} 1 {wrong # args: ftruncate [-fileid] file newsize}

Test filecmds-7.4 {ftruncate tests} {
    ftruncate -fileid TRUNCATE.TMP 10 1000 200
} 1 {wrong # args: ftruncate [-fileid] file newsize}

if [infox have_truncate] {
    Test filecmds-7.5 {ftruncate tests} {
        list [catch {ftruncate NOTHERE.TMP 10} msg] [string tolower $msg]
    } 0 {1 {nothere.tmp: no such file or directory}}

    Test filecmds-7.6 {ftruncate tests} {
        CreateTmpFile TRUNCATE.TMP 1000
        set sizes {}
        ftruncate TRUNCATE.TMP 500
        lappend sizes [file size TRUNCATE.TMP]
        ftruncate TRUNCATE.TMP 50
        lappend sizes [file size TRUNCATE.TMP]
        set sizes
    } 0 {500 50}

    Test filecmds-7.7 {ftruncate tests} {
        CreateTmpFile TRUNCATE.TMP 1000
        set sizes {}
        ftruncate TRUNCATE.TMP 1000
        lappend sizes [file size TRUNCATE.TMP]
        ftruncate TRUNCATE.TMP 0
        lappend sizes [file size TRUNCATE.TMP]
        set sizes
    } 0 {1000 0}
}

Test filecmds-7.7.1 {ftruncate tests} {
    ftruncate NOTHERE.TMP 10
} 1 {truncating files by path is not available on this system} pcOnly

if [infox have_ftruncate] {
    Test filecmds-7.8 {ftruncate tests} {
        ftruncate -fileid TRUNCATE.TMP 1000
    } 1 {can not find channel named "TRUNCATE.TMP"}

    Test filecmds-7.9 {ftruncate tests} {
        CreateTmpFile TRUNCATE.TMP 1000
        set sizes {}
        set fh [open TRUNCATE.TMP r+]
        ftruncate -fileid $fh 500
        lappend sizes [file size TRUNCATE.TMP] [fstat $fh size]
        ftruncate  -fileid $fh 50
        lappend sizes [file size TRUNCATE.TMP] [fstat $fh size]
        close $fh
        set sizes
    } 0 {500 500 50 50}

    Test filecmds-7.10 {ftruncate tests} {
        CreateTmpFile TRUNCATE.TMP 1000
        set sizes {}
        set fh [open TRUNCATE.TMP r+]
        ftruncate -fileid $fh 1000
        lappend sizes [file size TRUNCATE.TMP] [fstat $fh size]
        ftruncate -fileid $fh 0
        lappend sizes [file size TRUNCATE.TMP] [fstat $fh size]
        close $fh
        set sizes
    } 0 {1000 1000 0 0}
}

Test filecmds-7.10.1 {ftruncate tests} {
    set fh [open TRUNCATE.TMP w]
    set result [list [catch {ftruncate -fileid $fh 0} msg] $msg]
    close $fh
    set result
} 0 {1 {-fileid option is not available on MS Windows}} pcOnly

rename CreateTmpFile {}
unlink -nocomplain [glob -nocomplain *.TMP]

