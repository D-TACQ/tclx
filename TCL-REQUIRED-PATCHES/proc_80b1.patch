
Jean-Luc Fontaine (jfontain@mygale.org) wrote:
: namespace a {
:     namespace export proc
:     ::proc proc {args} {
:         eval ::proc $args
:     }
: }
: namespace import -force a::*
: proc p x {puts $x}
: p 0
:
: results in a "segmentation fault" error on my Linux box.

Jean-Luc,

This seg fault is caused when TclObjInterpProc tried to get the
name of the procedure to include it in the errorInfo traceback.
It used the objv pointer that had become invalid since the interpreter's
stack had been grown and reallocated. The patch below fixes this.

The error message it was trying to print out was 

	too many nested calls to Tcl_EvalObj (infinite loop?)

Your new "proc" procedure had been imported into the global
namespace, so the call it made to "::proc" resulted in a recursive
call on itself. 

  Brian

-------------------------------------------------------------

------- generic/tclProc.c -------
*** /tmp/da003SC	Wed Dec 31 16:00:00 1969
--- generic/tclProc.c	Fri May 30 13:44:05 1997
***************
*** 612,617 ****
--- 612,624 ----
      Var *compiledLocals = localStorage;
  
      /*
+      * Get the procedure's name.
+      * THIS FAILS IF THE PROC NAME'S STRING REP HAS A NULL.
+      */
+     
+     procName = Tcl_GetStringFromObj(objv[0], &nameLen);
+ 
+     /*
       * If necessary, compile the procedure's body. The compiler will
       * allocate frame slots for the procedure's non-argument local
       * variables. If the ByteCode already exists, make sure it hasn't been
***************
*** 642,648 ****
  	     * are about to compile.
  	     */
  
- 	    procName = Tcl_GetStringFromObj(objv[0], &nameLen);
  	    numChars = nameLen;
  	    ellipsis = "";
  	    if (numChars > 50) {
--- 649,654 ----
***************
*** 660,666 ****
  	
  	if (result != TCL_OK) {
  	    if (result == TCL_ERROR) {
- 		procName = Tcl_GetStringFromObj(objv[0], &nameLen);
  		numChars = nameLen;
  		ellipsis = "";
  		if (numChars > 50) {
--- 666,671 ----
***************
*** 817,829 ****
  	    result = TclUpdateReturnInfo(iPtr);
  	} else if (result == TCL_ERROR) {
  	    char msg[100];
- 	    
- 	    /*
- 	     * Record information telling where the error occurred.
- 	     * THIS FAILS IF THE PROC NAME'S STRING REP HAS A NULL.
- 	     */
- 
- 	    procName = Tcl_GetStringFromObj(objv[0], &nameLen);
  	    sprintf(msg, "\n    (procedure \"%.50s\" line %d)",
  		    procName, iPtr->errorLine);
  	    Tcl_AddObjErrorInfo(interp, msg, -1);
--- 822,827 ----


