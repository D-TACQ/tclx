
    The attached patch fixes a significant bug in the UNIX
    notifier of Tcl 8.0b1.  Without the patch,  the select mask
    for a file never shrinks, resulting in tight loops when a
    socket that at some prior time had a "writable" handler,
    has drained it's send buffer,  and no longer has a "writable" handler.

    This happens when the script is now reading a request on the socket,
    and will not be interested in "writable" events until the reply has been
    constructed.

    Far worse,  the "writable" bit in the select mask will persist even
    after the socket is closed if it had no "writable" handler when closed.
    This results in all future select calls returning -1 with errno EBADF.
    The script never again sees any file events.

    For details read on after the patch...

Index: unix/tclUnixNotfy.c
===================================================================
RCS file: /opt/cvs/tcl8/unix/tclUnixNotfy.c,v
retrieving revision 1.1.1.2
retrieving revision 1.2
diff -c -r1.1.1.2 -r1.2
*** 1.1.1.2	1997/05/29 18:11:19
--- 1.2	1997/05/30 00:07:37
***************
*** 226,237 ****
--- 226,243 ----
      bit = 1 << (fd%(NBBY*sizeof(fd_mask)));
      if (mask & TCL_READABLE) {
  	notifier.checkMasks[index] |= bit;
+     } else {
+ 	notifier.checkMasks[index] &= ~bit;
      }
      if (mask & TCL_WRITABLE) {
  	(notifier.checkMasks+MASK_SIZE)[index] |= bit;
+     } else {
+ 	(notifier.checkMasks+MASK_SIZE)[index] &= ~bit;
      }
      if (mask & TCL_EXCEPTION) {
  	(notifier.checkMasks+2*(MASK_SIZE))[index] |= bit;
+     } else {
+ 	(notifier.checkMasks+2*(MASK_SIZE))[index] &= ~bit;
      }
      if (notifier.numFdBits <= fd) {
  	notifier.numFdBits = fd+1;

SAMPLE CODE:

    The following script illustrates the problem,
    invoke as
    
	serverbox% tclsh8.0 sockevent.tcl server 23456
	clientbox% tclsh8.0 sockevent.tcl client 23456 serverbox
	...
	...miscellaneous diagnostic output...
	...
	File: /etc/hosts
	...
	...miscellaneous diagnostic output...
	...
	File: /etc/hosts
	...
	...miscellaneous diagnostic output...
	...
	^D
	clientbox% tclsh8.0 sockevent.tcl client 23456 serverbox
	File: /etc/hosts
	...HUNG...

    After the first client request by the first client script,
    the server will burn gobs of CPU,  but will continue to function.

    After the first client disconnects,  the server is completely unable
    to process additional connections,  and never again calls the
    "accept" handle given to "socket -server".

    Take care running the server on Internet connected hosts,  it
    will gladly offer up any file readable by you to anyone who
    can guess the port number on which the server is running.

--- Cut here ----
#
#  Simple non-blocking client and server.
#
# State for each connection is stored in global array whose name is $sock.
#
# conn_info(rdata):  Data read so far.
# conn_info(wdata):  Data to be written.
# conn_info(fd):     File to copy to socket.
# conn_info(rsize):  Incoming message size.
# conn_info(rleft):  Incoming bytes remaining.
# conn_info(wleft):  Outgoing bytes remaining.
#

proc bgerror {err} {
    global errorInfo
    puts stderr "Error: $err\n$errorInfo"
}

proc conn_accept {sock host port} {
    upvar #0 $sock conn_info
    puts "Accepting $sock: Greetings [set conn_info(peer) $host:$port]"
    set conn_info(write_script) ""
    set conn_info(read_script) [list conn_request $sock]
    set conn_info(state) rsize
    fconfigure $sock -translation binary -blocking 0
    puts "Turn on read notification for $sock"
    fileevent $sock readable [list conn_readable $sock]
}

proc conn_close {sock} {
    upvar #0 $sock conn_info
    close $sock
    puts stderr "Closing $sock: Adios $conn_info(peer)"
    unset conn_info
}

proc conn_short {sock} {
    upvar #0 $sock conn_info
    close $sock
    set peer $conn_info(peer)
    unset conn_info
    error "Truncated message from: $peer"
}

proc conn_long {sock} {
    upvar #0 $sock conn_info
    close $sock
    set peer $conn_info(peer)
    unset conn_info
    error "Unexpected data after message from: $peer"
}

proc conn_readable {sock} {
    upvar #0 $sock conn_info
    switch -- $conn_info(state) {
	rsize {
	    if {[gets $sock conn_info(rleft)] == -1} {
		if {[eof $sock]} {
		    conn_close $sock
		}
		return
	    }
	    set conn_info(state) rdata
	    puts "Expecting $conn_info(rleft) bytes"
	    if {$conn_info(rleft) > 0} return
	    set conn_info(rdata) ""
	}
	rdata {
	    append conn_info(rdata) [set data [read $sock $conn_info(rleft)]]
	    set nread [string length $data]
	    puts "Read $nread bytes"
	    incr conn_info(rleft) -$nread
	    puts "$conn_info(rleft) bytes remaining"
	    if {$conn_info(rleft) > 0} {
		if {[eof $sock]} {
		    conn_short $sock
		}
		return
	    }
	}
	rdone {
	    read $sock 1
	    if {[fblocked $sock]} {
		puts "False readable"
		return
	    }
	    if {[eof $sock]} {
		conn_close $sock
	    } else {
		conn_long $sock
	    }
	    return
	}
    }
    set conn_info(state) rdone
    eval $conn_info(read_script)
}

proc conn_writable {sock} {
    upvar #0 $sock conn_info
    switch -- $conn_info(state) {
	writefile {
	    set fd $conn_info(fd)
	    puts "Write file block"
	    set buf [read $fd 4096]
	    puts -nonewline $sock $buf
	    flush $sock
	    set nwritten [string length $buf]
	    puts "Wrote $nwritten bytes"
	    puts "[incr conn_info(wleft) -$nwritten] bytes left"
	    if {![eof $fd]} return
	    unset conn_info(fd)
	    unset conn_info(wleft)
	    close $fd
	    set conn_info(state) rsize
	}
	writebuffer {
	    puts "Write: $conn_info(wdata)"
	    puts -nonewline $sock $conn_info(wdata)
	    flush $sock
	    unset conn_info(wdata)
	    set conn_info(state) rsize
	}
	connecting {
	    puts "Greetings $conn_info(peer)"
	    fconfigure $sock -translation binary -blocking 0
	    set conn_info(state) rdone
	}
    }
    puts "Turning off write notification for $sock"
    fileevent $sock writable {}
    eval $conn_info(write_script)
}

proc conn_reply {sock} {
    upvar #0 $sock conn_info
    puts "Received [string length $conn_info(rdata)] bytes"
    unset conn_info(rdata)
    set conn_info(iodone) 1
}

proc conn_request {sock} {
    upvar #0 $sock conn_info
    set file $conn_info(rdata)
    unset conn_info(rdata)
    puts "Requested: $file"
    if {[catch {open $file r} fd]} {
	puts $sock 0
	flush $sock
	set conn_info(state) rsize
	return
    }
    fconfigure $fd -translation binary
    puts $sock [set conn_info(wleft) [file size $file]]
    set conn_info(fd) $fd
    set conn_info(state) writefile
    puts "Turn on write notification for $sock"
    fileevent $sock writable [list conn_writable $sock]
}

proc conn_loop {sock} {
    upvar #0 $sock conn_info
    set conn_info(write_script) ""
    while {[gets stdin file] != -1} {
	puts $sock [string length $file]
	set conn_info(wdata) $file
	set conn_info(state) writebuffer
	puts "Turn on write notification for $sock"
	fileevent $sock writable [list conn_writable $sock]
	vwait conn_info(iodone)
	if {![info exists conn_info(peer)]} break
    }
    conn_close $sock
}

#
# Parse args.
#
foreach {role port host} $argv break

#
# Set up event loop.
#
switch -- $role {
    server {
	set sock [socket -server conn_accept $port]
	puts "Server socket is: $sock"
	vwait forever
    }
    client {
	set sock [socket -async $host $port]
	upvar #0 $sock conn_info
	set conn_info(peer) $host:$port
	set conn_info(state) connecting
	set conn_info(read_script)   [list conn_reply $sock]
	set conn_info(write_script)  [list conn_loop $sock]
	puts "Turn on read notification for $sock"
	fileevent $sock readable [list conn_readable $sock]
	puts "Turn on write notification for $sock"
	fileevent $sock writable [list conn_writable $sock]
	vwait conn_info(peer)
    }
}
--- Cut here ----


