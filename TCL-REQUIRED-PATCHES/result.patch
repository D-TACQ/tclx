Fixes break and continue failing to clear the result as the old commands would
have.


*** generic/tclExecute.c.ORG	Tue Jun 17 21:42:45 1997
--- generic/tclExecute.c	Tue Jun 17 21:52:19 1997
***************
*** 1032,1038 ****
  		case TCL_CONTINUE:
  		    /*
  		     * The invoked command requested a break or continue.
! 		     * Find the closest enclosing loop or catch exception
  		     * range, if any. If a loop is found, terminate its
  		     * execution or skip to its next iteration. If the
  		     * closest is a catch exception range, jump to its
--- 1032,1039 ----
  		case TCL_CONTINUE:
  		    /*
  		     * The invoked command requested a break or continue.
! 		     * First reset the interpreter's result. Then find
! 		     * the closest enclosing loop or catch exception
  		     * range, if any. If a loop is found, terminate its
  		     * execution or skip to its next iteration. If the
  		     * closest is a catch exception range, jump to its
***************
*** 1150,1158 ****
  		ADJUST_PC(1);
  	    } else if ((result == TCL_BREAK) || (result == TCL_CONTINUE)) {
  		/*
! 		 * Find the closest enclosing loop or catch exception range,
! 		 * if any. If a loop is found, terminate its execution or
! 		 * skip to its next iteration. If the closest is a catch
  		 * exception range, jump to its catchOffset. If no enclosing
  		 * range is found, stop execution and return that same
  		 * TCL_BREAK or TCL_CONTINUE.
--- 1151,1160 ----
  		ADJUST_PC(1);
  	    } else if ((result == TCL_BREAK) || (result == TCL_CONTINUE)) {
  		/*
! 		 * First reset the interpreter's result. Then find the
! 		 * closest enclosing loop or catch exception range, if
! 		 * any. If a loop is found, terminate its execution or skip
! 		 * to its next iteration. If the closest is a catch
  		 * exception range, jump to its catchOffset. If no enclosing
  		 * range is found, stop execution and return that same
  		 * TCL_BREAK or TCL_CONTINUE.
***************
*** 2705,2717 ****
  	    ADJUST_PC(1);
  
  	case INST_BREAK:
! 	    /* Find the closest enclosing loop or catch exception range,
! 	     * if any. If a loop is found, terminate its execution.
! 	     * If the closest is a catch exception range, jump to its
! 	     * catchOffset. If no enclosing range is found, stop
! 	     * execution and return TCL_BREAK.
  	     */
! 	
  	    rangePtr = TclGetExceptionRangeForPc(pc, /*catchOnly*/ 0,
  		    codePtr);
  	    if (rangePtr == NULL) {
--- 2707,2721 ----
  	    ADJUST_PC(1);
  
  	case INST_BREAK:
! 	    /*
! 	     * First reset the interpreter's result. Then find the closest
! 	     * enclosing loop or catch exception range, if any. If a loop is
! 	     * found, terminate its execution. If the closest is a catch
! 	     * exception range, jump to its catchOffset. If no enclosing
! 	     * range is found, stop execution and return TCL_BREAK.
  	     */
! 
! 	    Tcl_ResetResult(interp);
  	    rangePtr = TclGetExceptionRangeForPc(pc, /*catchOnly*/ 0,
  		    codePtr);
  	    if (rangePtr == NULL) {
***************
*** 2743,2749 ****
  	     * catchOffset. If no enclosing range is found, stop
  	     * execution and return TCL_CONTINUE.
  	     */
! 	
  	    rangePtr = TclGetExceptionRangeForPc(pc, /*catchOnly*/ 0,
  		    codePtr);
  	    if (rangePtr == NULL) {
--- 2747,2754 ----
  	     * catchOffset. If no enclosing range is found, stop
  	     * execution and return TCL_CONTINUE.
  	     */
! 
! 	    Tcl_ResetResult(interp);
  	    rangePtr = TclGetExceptionRangeForPc(pc, /*catchOnly*/ 0,
  		    codePtr);
  	    if (rangePtr == NULL) {
