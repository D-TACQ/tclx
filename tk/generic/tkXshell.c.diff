*** ../../../tk4.1b1/generic/tkMain.c	Wed Jan 31 13:08:31 1996
--- tkXshell.c	Mon Feb 12 10:17:19 1996
***************
*** 1,3 ****
--- 1,22 ----
+ /*
+  * tkXshell.c
+  *
+  * Version of Tk main that is modified to build a wish shell with the Extended
+  * Tcl command set and libraries.  This makes it easier to use a different
+  * main.
+  *-----------------------------------------------------------------------------
+  * Copyright 1991-1996 Karl Lehenbauer and Mark Diekhans.
+  *
+  * Permission to use, copy, modify, and distribute this software and its
+  * documentation for any purpose and without fee is hereby granted, provided
+  * that the above copyright notice appear in all copies.  Karl Lehenbauer and
+  * Mark Diekhans make no representations about the suitability of this
+  * software for any purpose.  It is provided "as is" without express or
+  * implied warranty.
+  *-----------------------------------------------------------------------------
+  * $Id: tkXshell.c,v 5.5 1996/02/12 18:17:19 markd Exp $
+  *-----------------------------------------------------------------------------
+  */
  /* 
   * tkMain.c --
   *
***************
*** 8,31 ****
   *	for Tk applications.
   *
   * Copyright (c) 1990-1994 The Regents of the University of California.
!  * Copyright (c) 1994-1995 Sun Microsystems, Inc.
   *
   * See the file "license.terms" for information on usage and redistribution
   * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
   */
  
! static char sccsid[] = "@(#) tkMain.c 1.136 96/01/31 13:08:42";
  
  #include <ctype.h>
  #include <stdio.h>
! #include <string.h>
! #include <tcl.h>
  #include <tk.h>
- #ifdef NO_STDLIB_H
- #   include "../compat/stdlib.h"
- #else
- #   include <stdlib.h>
- #endif
  
  /*
   * Declarations for various library procedures and variables (don't want
--- 27,44 ----
   *	for Tk applications.
   *
   * Copyright (c) 1990-1994 The Regents of the University of California.
!  * Copyright (c) 1994-1996 Sun Microsystems, Inc.
   *
   * See the file "license.terms" for information on usage and redistribution
   * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
   */
  
! static char sccsid[] = "@(#) tkMain.c 1.136 96/01/17 09:32:28";
  
  #include <ctype.h>
  #include <stdio.h>
! #include <tclExtdInt.h>
  #include <tk.h>
  
  /*
   * Declarations for various library procedures and variables (don't want
***************
*** 36,43 ****
   * some systems.
   */
  
- extern int		isatty _ANSI_ARGS_((int fd));
- extern int		read _ANSI_ARGS_((int fd, char *buf, size_t size));
  extern char *		strrchr _ANSI_ARGS_((CONST char *string, int c));
  
  /*
--- 49,54 ----
***************
*** 57,62 ****
--- 68,74 ----
  				 * holds argv[0] from the command line.  This
  				 * value is used as a default for the
  				 * application name. */
+ static int gotPartial = 0;
  
  /*
   * Forward declarations for procedures defined later in this file.
***************
*** 69,80 ****
  static void		Prompt _ANSI_ARGS_((Tcl_Interp *interp, int partial));
  static void		StdinProc _ANSI_ARGS_((ClientData clientData,
  			    int mask));
  EXTERN char *		TkDefaultAppName _ANSI_ARGS_((void));
  
  /*
   *----------------------------------------------------------------------
   *
!  * Tk_Main --
   *
   *	Main program for Wish and most other Tk-based applications.
   *
--- 81,93 ----
  static void		Prompt _ANSI_ARGS_((Tcl_Interp *interp, int partial));
  static void		StdinProc _ANSI_ARGS_((ClientData clientData,
  			    int mask));
+ static void		SignalProc _ANSI_ARGS_((int  signalNum));
  EXTERN char *		TkDefaultAppName _ANSI_ARGS_((void));
  
  /*
   *----------------------------------------------------------------------
   *
!  * TkX_Main --
   *
   *	Main program for Wish and most other Tk-based applications.
   *
***************
*** 91,97 ****
   */
  
  void
! Tk_Main(argc, argv, appInitProc)
      int argc;				/* Number of arguments. */
      char **argv;			/* Array of argument strings. */
      Tcl_AppInitProc *appInitProc;	/* Application-specific initialization
--- 104,110 ----
   */
  
  void
! TkX_Main(argc, argv, appInitProc)
      int argc;				/* Number of arguments. */
      char **argv;			/* Array of argument strings. */
      Tcl_AppInitProc *appInitProc;	/* Application-specific initialization
***************
*** 153,162 ****
      Tcl_SetVar(interp, "argv0", argv0, TCL_GLOBAL_ONLY);
  
      /*
-      * Set the "tcl_interactive" variable.
-      */
- 
-     /*
       * For now, under Windows, we assume we are not running as a console mode
       * app, so we need to use the GUI console.  In order to enable this, we
       * always claim to be running on a tty.  This probably isn't the right
--- 166,171 ----
***************
*** 170,184 ****
  #endif
      Tcl_SetVar(interp, "tcl_interactive",
  	    ((fileName == NULL) && tty) ? "1" : "0", TCL_GLOBAL_ONLY);
  
      /*
       * Invoke application-specific initialization.
       */
  
      if ((*appInitProc)(interp) != TCL_OK) {
! 	    Tcl_Write(errChannel, "initialization failed: ", -1);
! 	    Tcl_Write(errChannel, interp->result, -1);
! 	    Tcl_Write(errChannel, "\n", 1);
      }
  
      /*
--- 179,193 ----
  #endif
      Tcl_SetVar(interp, "tcl_interactive",
  	    ((fileName == NULL) && tty) ? "1" : "0", TCL_GLOBAL_ONLY);
+     if ((fileName == NULL) && tty)
+         Tcl_SetupSigInt ();
  
      /*
       * Invoke application-specific initialization.
       */
  
      if ((*appInitProc)(interp) != TCL_OK) {
!         TclX_ErrorExit (interp, 255);
      }
  
      /*
***************
*** 186,192 ****
       */
  
      if (fileName != NULL) {
! 	code = Tcl_EvalFile(interp, fileName);
  	if (code != TCL_OK) {
  	    goto error;
  	}
--- 195,204 ----
       */
  
      if (fileName != NULL) {
! 	code = TclX_Eval (interp,
!                           TCLX_EVAL_GLOBAL | TCLX_EVAL_FILE |
!                           TCLX_EVAL_ERR_HANDLER,
!                           fileName);
  	if (code != TCL_OK) {
  	    goto error;
  	}
***************
*** 200,245 ****
  	 * input, and print a prompt if the input device is a terminal.
  	 */
  
! 	fileName = Tcl_GetVar(interp, "tcl_rcFileName", TCL_GLOBAL_ONLY);
! 
! 	if (fileName != NULL) {
! 	    Tcl_DString buffer;
! 	    char *fullName;
!     
! 	    fullName = Tcl_TranslateFileName(interp, fileName, &buffer);
! 	    if (fullName == NULL) {
! 		Tcl_Write(errChannel, interp->result, -1);
! 		Tcl_Write(errChannel, "\n", 1);
! 	    } else {
! 
!                 /*
!                  * NOTE: The following relies on O_RDONLY==0.
!                  */
!                 
!                 chan = Tcl_OpenFileChannel(interp, fullName, "r", 0);
!                 if (chan != (Tcl_Channel) NULL) {
!                     Tcl_Close(chan);
!                     if (Tcl_EvalFile(interp, fullName) != TCL_OK) {
!                         Tcl_Write(errChannel, interp->result, -1);
!                         Tcl_Write(errChannel, "\n", 1);
!                     }
!                 }
!             }
              
- 	    Tcl_DStringFree(&buffer);
- 	}
  
  	/*
  	 * Establish a channel handler for stdin.
  	 */
  
          Tcl_CreateChannelHandler(inChannel, TCL_READABLE, StdinProc,
                  (ClientData) inChannel);
  	if (tty) {
! 	    Prompt(interp, 0);
  	}
      }
  
      Tcl_Flush(outChannel);
      Tcl_DStringInit(&command);
      Tcl_DStringInit(&line);
--- 212,233 ----
  	 * input, and print a prompt if the input device is a terminal.
  	 */
  
!         TclX_EvalRCFile (interp);
              
  
  	/*
  	 * Establish a channel handler for stdin.
  	 */
  
+         tclErrorSignalProc = SignalProc;
          Tcl_CreateChannelHandler(inChannel, TCL_READABLE, StdinProc,
                  (ClientData) inChannel);
  	if (tty) {
! 	    TclX_OutputPrompt (interp, 1);
  	}
      }
  
+     tclSignalBackgroundError = Tk_BackgroundError;
      Tcl_Flush(outChannel);
      Tcl_DStringInit(&command);
      Tcl_DStringInit(&line);
***************
*** 260,266 ****
      }
      Tcl_Write(errChannel, msg, -1);
      Tcl_Write(errChannel, "\n", 1);
!     Tcl_Exit(1);
  }
  
  /*
--- 248,282 ----
      }
      Tcl_Write(errChannel, msg, -1);
      Tcl_Write(errChannel, "\n", 1);
!     if (!tclDeleteInterpAtEnd) {
!         Tcl_Exit(1);
!     } else {
!         Tcl_DeleteInterp (interp);
!         Tcl_Exit(1);
!     }
! }
! 
! /*
!  *----------------------------------------------------------------------
!  *
!  * SignalProc --
!  *
!  *	Function called on a signal generating an error to clear the stdin
!  *   	buffer.
!  *----------------------------------------------------------------------
!  */
! 
! static void
! SignalProc (signalNum)
!     int  signalNum;
! {
!     tclGotErrorSignal = 0;
!     Tcl_DStringFree (&command);
!     gotPartial = 0;
!     if (tty) {
!         Tcl_Write (TclX_Stdout (interp), "\n", 1);
!         TclX_OutputPrompt (interp, !gotPartial);
!     }
  }
  
  /*
***************
*** 289,295 ****
      ClientData clientData;		/* Not used. */
      int mask;				/* Not used. */
  {
-     static int gotPartial = 0;
      char *cmd;
      int code, count;
      Tcl_Channel chan = (Tcl_Channel) clientData;
--- 305,310 ----
***************
*** 336,349 ****
      Tcl_DStringFree(&command);
      if (*interp->result != 0) {
  	if ((code != TCL_OK) || (tty)) {
! 	    /*
! 	     * The statement below used to call "printf", but that resulted
! 	     * in core dumps under Solaris 2.3 if the result was very long.
!              *
!              * NOTE: This probably will not work under Windows either.
! 	     */
! 
! 	    puts(interp->result);
  	}
      }
  
--- 351,357 ----
      Tcl_DStringFree(&command);
      if (*interp->result != 0) {
  	if ((code != TCL_OK) || (tty)) {
!             TclX_PrintResult (interp, code, cmd);
  	}
      }
  
***************
*** 353,413 ****
  
      prompt:
      if (tty) {
! 	Prompt(interp, gotPartial);
      }
      Tcl_ResetResult(interp);
- }
- 
- /*
-  *----------------------------------------------------------------------
-  *
-  * Prompt --
-  *
-  *	Issue a prompt on standard output, or invoke a script
-  *	to issue the prompt.
-  *
-  * Results:
-  *	None.
-  *
-  * Side effects:
-  *	A prompt gets output, and a Tcl script may be evaluated
-  *	in interp.
-  *
-  *----------------------------------------------------------------------
-  */
- 
- static void
- Prompt(interp, partial)
-     Tcl_Interp *interp;			/* Interpreter to use for prompting. */
-     int partial;			/* Non-zero means there already
- 					 * exists a partial command, so use
- 					 * the secondary prompt. */
- {
-     char *promptCmd;
-     int code;
-     Tcl_Channel outChannel, errChannel;
- 
-     outChannel = Tcl_GetChannel(interp, "stdout", NULL);
-     errChannel = Tcl_GetChannel(interp, "stderr", NULL);
- 
-     promptCmd = Tcl_GetVar(interp,
- 	partial ? "tcl_prompt2" : "tcl_prompt1", TCL_GLOBAL_ONLY);
-     if (promptCmd == NULL) {
- defaultPrompt:
- 	if (!partial) {
- 	    Tcl_Write(outChannel, "% ", 2);
- 	}
-     } else {
- 	code = Tcl_Eval(interp, promptCmd);
- 	if (code != TCL_OK) {
- 	    Tcl_AddErrorInfo(interp,
- 		    "\n    (script that generates prompt)");
- 		    Tcl_Write(errChannel, interp->result, -1);
- 		    Tcl_Write(errChannel, "\n", 1);
- 	    goto defaultPrompt;
- 	}
-     }
-     Tcl_Flush(outChannel);
  }
  
  /*
--- 361,369 ----
  
      prompt:
      if (tty) {
!         TclX_OutputPrompt (interp, !gotPartial);
      }
      Tcl_ResetResult(interp);
  }
  
  /*
