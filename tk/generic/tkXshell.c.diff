0a1,19
> /*
>  * tkXshell.c
>  *
>  * Version of Tk main that is modified to build a wish shell with the Extended
>  * Tcl command set and libraries.  This makes it easier to use a different
>  * main.
>  *-----------------------------------------------------------------------------
>  * Copyright 1991-1996 Karl Lehenbauer and Mark Diekhans.
>  *
>  * Permission to use, copy, modify, and distribute this software and its
>  * documentation for any purpose and without fee is hereby granted, provided
>  * that the above copyright notice appear in all copies.  Karl Lehenbauer and
>  * Mark Diekhans make no representations about the suitability of this
>  * software for any purpose.  It is provided "as is" without express or
>  * implied warranty.
>  *-----------------------------------------------------------------------------
>  * $Id: tkXshell.c,v 5.7 1996/02/20 01:13:13 markd Exp $
>  *-----------------------------------------------------------------------------
>  */
11c30
<  * Copyright (c) 1994-1995 Sun Microsystems, Inc.
---
>  * Copyright (c) 1994-1996 Sun Microsystems, Inc.
17c36
< static char sccsid[] = "@(#) tkMain.c 1.136 96/01/31 13:08:42";
---
> static char sccsid[] = "@(#) tkMain.c 1.136 96/01/17 09:32:28";
21,22c40
< #include <string.h>
< #include <tcl.h>
---
> #include <tclExtdInt.h>
24,28d41
< #ifdef NO_STDLIB_H
< #   include "../compat/stdlib.h"
< #else
< #   include <stdlib.h>
< #endif
39,40d51
< extern int		isatty _ANSI_ARGS_((int fd));
< extern int		read _ANSI_ARGS_((int fd, char *buf, size_t size));
59a71
> static int gotPartial = 0;
71a84
> static void		SignalProc _ANSI_ARGS_((int  signalNum));
77c90
<  * Tk_Main --
---
>  * TkX_Main --
94c107
< Tk_Main(argc, argv, appInitProc)
---
> TkX_Main(argc, argv, appInitProc)
107a121,126
>     TclX_SetAppInfo (TRUE,
>                      "wishx",
>                      "Extended Wish",
>                      TKX_VERSION,
>                      TCLX_PATCHLEVEL);
> 
156,159d174
<      * Set the "tcl_interactive" variable.
<      */
< 
<     /*
172a188,189
>     if ((fileName == NULL) && tty)
>         Tcl_SetupSigInt ();
179,181c196
< 	    Tcl_Write(errChannel, "initialization failed: ", -1);
< 	    Tcl_Write(errChannel, interp->result, -1);
< 	    Tcl_Write(errChannel, "\n", 1);
---
>         TclX_ErrorExit (interp, 255);
189c204,207
< 	code = Tcl_EvalFile(interp, fileName);
---
> 	code = TclX_Eval (interp,
>                           TCLX_EVAL_GLOBAL | TCLX_EVAL_FILE |
>                           TCLX_EVAL_ERR_HANDLER,
>                           fileName);
203,227c221
< 	fileName = Tcl_GetVar(interp, "tcl_rcFileName", TCL_GLOBAL_ONLY);
< 
< 	if (fileName != NULL) {
< 	    Tcl_DString buffer;
< 	    char *fullName;
<     
< 	    fullName = Tcl_TranslateFileName(interp, fileName, &buffer);
< 	    if (fullName == NULL) {
< 		Tcl_Write(errChannel, interp->result, -1);
< 		Tcl_Write(errChannel, "\n", 1);
< 	    } else {
< 
<                 /*
<                  * NOTE: The following relies on O_RDONLY==0.
<                  */
<                 
<                 chan = Tcl_OpenFileChannel(interp, fullName, "r", 0);
<                 if (chan != (Tcl_Channel) NULL) {
<                     Tcl_Close(chan);
<                     if (Tcl_EvalFile(interp, fullName) != TCL_OK) {
<                         Tcl_Write(errChannel, interp->result, -1);
<                         Tcl_Write(errChannel, "\n", 1);
<                     }
<                 }
<             }
---
>         TclX_EvalRCFile (interp);
229,230d222
< 	    Tcl_DStringFree(&buffer);
< 	}
235a228
>         tclErrorSignalProc = SignalProc;
239c232
< 	    Prompt(interp, 0);
---
> 	    TclX_OutputPrompt (interp, 1);
242a236
>     tclSignalBackgroundError = Tk_BackgroundError;
263c257,285
<     Tcl_Exit(1);
---
>     if (!tclDeleteInterpAtEnd) {
>         Tcl_Exit(1);
>     } else {
>         Tcl_DeleteInterp (interp);
>         Tcl_Exit(1);
>     }
> }
> 
> /*
>  *----------------------------------------------------------------------
>  *
>  * SignalProc --
>  *
>  *	Function called on a signal generating an error to clear the stdin
>  *   	buffer.
>  *----------------------------------------------------------------------
>  */
> 
> static void
> SignalProc (signalNum)
>     int  signalNum;
> {
>     tclGotErrorSignal = 0;
>     Tcl_DStringFree (&command);
>     gotPartial = 0;
>     if (tty) {
>         Tcl_Write (TclX_Stdout (interp), "\n", 1);
>         TclX_OutputPrompt (interp, !gotPartial);
>     }
292d313
<     static int gotPartial = 0;
339,346c360
< 	    /*
< 	     * The statement below used to call "printf", but that resulted
< 	     * in core dumps under Solaris 2.3 if the result was very long.
<              *
<              * NOTE: This probably will not work under Windows either.
< 	     */
< 
< 	    puts(interp->result);
---
>             TclX_PrintResult (interp, code, cmd);
356c370
< 	Prompt(interp, gotPartial);
---
>         TclX_OutputPrompt (interp, !gotPartial);
359,410d372
< }
< 
< /*
<  *----------------------------------------------------------------------
<  *
<  * Prompt --
<  *
<  *	Issue a prompt on standard output, or invoke a script
<  *	to issue the prompt.
<  *
<  * Results:
<  *	None.
<  *
<  * Side effects:
<  *	A prompt gets output, and a Tcl script may be evaluated
<  *	in interp.
<  *
<  *----------------------------------------------------------------------
<  */
< 
< static void
< Prompt(interp, partial)
<     Tcl_Interp *interp;			/* Interpreter to use for prompting. */
<     int partial;			/* Non-zero means there already
< 					 * exists a partial command, so use
< 					 * the secondary prompt. */
< {
<     char *promptCmd;
<     int code;
<     Tcl_Channel outChannel, errChannel;
< 
<     outChannel = Tcl_GetChannel(interp, "stdout", NULL);
<     errChannel = Tcl_GetChannel(interp, "stderr", NULL);
< 
<     promptCmd = Tcl_GetVar(interp,
< 	partial ? "tcl_prompt2" : "tcl_prompt1", TCL_GLOBAL_ONLY);
<     if (promptCmd == NULL) {
< defaultPrompt:
< 	if (!partial) {
< 	    Tcl_Write(outChannel, "% ", 2);
< 	}
<     } else {
< 	code = Tcl_Eval(interp, promptCmd);
< 	if (code != TCL_OK) {
< 	    Tcl_AddErrorInfo(interp,
< 		    "\n    (script that generates prompt)");
< 		    Tcl_Write(errChannel, interp->result, -1);
< 		    Tcl_Write(errChannel, "\n", 1);
< 	    goto defaultPrompt;
< 	}
<     }
<     Tcl_Flush(outChannel);
